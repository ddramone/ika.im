---
title: 'Building a Browser using ElectronJS'
publishedAt: '2025-02-09'
summary: 'How we built a browser in ElectronJS using BrowserViews.'
home-image: '/images/stack-browser/electron-framed.svg'
image: '/images/bitmasking/og-electron-framed.png'
---


This post is about how we at Stack built a browser using [ElectronJS](https://www.electronjs.org/).

If you're curious why we chose ElectronJS in the first place, I've written about our journey here: [Technology Behind Stack Browser](https://www.ika.im/posts/tech-behind-stack-browser)

I'll skip the basics and assume you're already familiar with ElectronJS and how the main and renderer processes work.

Alright, let's dive in.

## How to display web content


In Electron, UI typically lives in the renderer process as a  standard web app. However, when building a browser, we need to display the content of websites that users visit. For this the [BrowserView](https://www.electronjs.org/docs/latest/api/browser-view) component is the best option.

That wasn‚Äôt always the case, though. In the past, the only option was the `<WebView>` tag (which worked like an iframe). If you‚Äôre curious why BrowserView is a better alternative, Figma and Slack have good posts about it:
* [Figma - Introducing BrowserView for Electron
](https://www.figma.com/blog/introducing-browserview-for-electron/)
* [Slack - Migrating to BrowserView](https://slack.engineering/growing-pains-migrating-slacks-desktop-app-to-browserview/)

## What is a BrowserView

A **BrowserView** is a native component managed by the main process. You can position it on the screen by giving coordinates and a size. And it can load a web content. That‚Äôs essentially all it can do.

```ts
const { app, BrowserView, BrowserWindow } = require('electron')

app.whenReady().then(() => {
  const win = new BrowserWindow({ ... })

  const view = new BrowserView()
  win.setBrowserView(view)
  
  view.setBounds({ x: 0, y: 0, width: 300, height: 300 })
  view.webContents.loadURL('https://electronjs.org')
})
```

A key thing to understand is that the BrowserView sits above everything else, which means the entire UI running as a web app in the renderer process gets buried behind it.

<Image src="/images/stack-browser/floating-browserview.png" alt="Extensions Dropdown" width={993} height={732} />

UI elements that need to appear above the web-site content - such as dropdowns, command bars, or floating sidebars - cannot be part of the document running in the renderer process.

This post is purely about how we solved this challenge.

***Disclaimer**: The BrowserView API is now deprecated and has been replaced by [WebContentsView](https://www.electronjs.org/docs/latest/api/web-contents-view). While the API differs slightly, the core idea remains the same. I‚Äôll be referring to BrowserView throughout this post, as it‚Äôs easier for me to explain the concepts and show some snippets.*



## Layering UI elements

In a regular web app, layering elements is simple because everything exists within the same document flow, and you can control the stacking order with z-index. But when a BrowserView sits above everything else, things get tricky. 

Let‚Äôs take a simple example: we want to build a browser that only displays one website. It features a topbar, with a dropdown menu in the right corner. *(This is actual MVP that we created in the beginning)*


At first we created a simple web app in the renderer process with only a `<Topbar>` component positioned at the top, occupying 50px in height.


Then, in the main process, we created a `BrowserView` instance that occupies the remaining screen space, starting just below the topbar.

The button to open a dropdown is part of our Topbar component.  But how do we make sure that the dropdown content doesn‚Äôt get buried behind the BrowserView?

<Image src="/images/stack-browser/floating-dropdown-problem.png" alt="Extensions Dropdown" width={993} height={732} />


Guess what... **we used another BrowserView**

BrowserViews are great for displaying websites, but they can actually render any web content.

This means we could create a new BrowserView, position it precisely where the dropdown should appear, and use it to render only the dropdown‚Äôs content.

For our MVP, we created a separate `dropdown.html` file with its own styles, just like a standalone webpage. Then, we created a second BrowserView with a transparent background, loaded our `dropdown.html`, and positioned it directly on top of the existing BrowserView that was displaying the website content.

<Image src="/images/stack-browser/dropdown-as-a-new-broweserview.png" alt="Extensions Dropdown" width={608} height={240} />

This opened new doors. We could create BrowserViews for every floating UI element. But as you might imagine it comes with a whole chain of challenges: 

* **How to distribute different parts of the UI in BrowserViews?** How do they communicate with each other? How do you keep their states in sync?

	For example, say we have a dropdown item to toggle dark mode. When the user clicks it, the topbar should switch to dark. How do we ensure this happens smoothly?

	Managing these interactions becomes a major architectural challenge ‚Äî one that requires a solid strategy for state management and cross-view communication.

* **How to manage the layout**. BrowserView only allows us to set its size and position on the screen, but that‚Äôs about it. Unlike regular HTML elements, there‚Äôs no built-in layout system, no CSS flexbox, no z-index. Manually updating coordinates every time something changes quickly becomes a nightmare.

	Instead hardcoding sizes and coordinates for every BrowserView, we wanted a system that could dynamically adjust everything based on the app‚Äôs structure.

This problems are independent from each other, but let‚Äôs start with the first one: 

## Distributing UI Across BrowserViews

As already mentioned, BrowserView can display any web content ‚Äî it can load a URL, render a local HTML file, or even **reuse an existing [WebContents](https://www.electronjs.org/docs/latest/api/web-contents) instance**.

Meanwhile, in the renderer process, we can create new windows using `window.open()`. Normally this opens a separate window, but we only need its `WebContents` instance.

By combining these two pieces of the puzzle here‚Äôs what we do:

- We have one React web app running in the renderer. This app opens bunch of windows for each floating ui element using `window.open()` and projects DOM in those windows.
- In the main process we intercept opening windows before they appear, steal their `WebContent` instances, and instead we put them into their own BrowserViews and position precisely where we want.

Ok, let‚Äôs go through this steps in more details.

### Distribute UI in sub windows 

In JavaScript, the parent window has full access to the document of opened child windows.

```
const dropdownWindow = window.open('');
dropdownWindow.document.body.innerText = 'Yoo from the parent';
```

Using [React Portals](https://react.dev/reference/react-dom/createPortal) it gets more interesting. You can project any part of the React component in another window.


Take a look at the following example.

```ts
function Topbar() {
 
 const [isDark, toggleTheme] = useReducer(s => !s, false);
 
 return <Container dark={isDarkMode}>
  <Title>...</Title>
 
  <Dropdown>
   <Dropdown.Trigger>...</Dropdown.Trigger>

   //üëáüëáüëá
   <PortalWindow>
    <Dropdown.Content>
     <Button onClick={toggleTheme}>Toggle Dark Mode</Button>
    </Dropdown.Content>
   <PortalWindow>
  </Dropdown>

 </Container>
}
```



In this snippet, we have a `<Topbar>` component containing both the dropdown trigger and the dropdown content. The dropdown trigger is part of the topbar as expected, but the dropdown content is rendered in a new window. This is achieved by wrapping the dropdown content inside our custom `<PortalWindow>` component, which moves it out of the normal document flow and into a separate window.

[This article by David Gilbertson explains the technique very nicely](https://david-gilbertson.medium.com/using-a-react-16-portal-to-do-something-cool-2a2d627b0202)

This way we don‚Äôt need to create separate `dropdown.html` file, instead it simply becomes one small part of a component.

Now let‚Äôs move to the second part of the puzzle:

## Intercepting window.open in the main process

Instead of letting `window.open()` to create an actual window, we intercept it in the main process, take its WebContents, embed it into a **BrowserView** instead and position it based on our needs.

```js
// in the renderer process:
window.open('','dropdown')

// in the main process:
mainWindow.webContents.removeAllListeners('-add-new-contents')
mainWindow.webContents.addListener(
  '-add-new-contents',
  (event, webContents, ...args) => {
    const dropdownView = new BrowserView({ webContents })

    dropdownView.setBounds({
      x: 500,
      y: 30,
      width: 300,
      height: 800,
    })

    mainWindow.addBrowserView(dropdownView)
    mainWindow.setTopBrowserView(dropdownView)

  },
)
```

The `-add-new-contents` event isn‚Äôt officially documented, but it works. It was [introduced by @sentialx](https://github.com/electron/electron/pull/26802), who has made many great contributions to Electron, particularly for building browsers.


### Putting it all together

* We have one React app running in the renderer process, the way you‚Äôd normally use Electron.
* This app holds the entire UI state and behaves like a regular web app.
* It opens bunch of windows for each floating UI component - like dropdown, modals, tooltips, sidebar - by simply wrapping them  inside `<PortalWindow`>
* In the main process, we intercept opening a window before it appears, steal its `WebContent` and put it into a new `BrowserView`
* And  we position the `BrowserView` where it belongs.

This way we can overlay BrowserViews on top of each other as much as we like by having our dev experience to be *almost* identical to normal web app development.


### Few additional gotchas:

* The new windows we create don‚Äôt automatically **inherit styles** from our main app. Even though the components inside them work fine, they look completely unstyled html.

	We used **Styled Components**, which provides an easy way to inject styles of the specific DOM tree into given element instead of main documents `<head>`. So the solution to this problem was simply a ‚Äúone-liner‚Äù.

	```ts
	// in our PortalWindow.ts
	<StyleSheetManager target={myWindow.document.head}>
	  {createPortal(children, myWindow.document.body)}
	</StyleSheetManager>
	```

* Another challenge was registering **global keyboard shortcuts**. We had to make sure that all windows captured keystrokes individually, because depending where you click different window gets activated. We solved this by listening to `before-input-event` in the main process, but there are possibly other ways.

* **Debugging** is pretty much the same as in a normal web app. The only difference is that we had to make sure to open  a dev tools of the right ‚Äúwindow‚Äù when inspecting styles. Not a big deal.

* **Performance** was noticeably slow when opening new windows. To make it feel instant, we pre-opened a few empty windows and reused them instead of calling window.open every time a dropdown was opened.

* Unfortunately there‚Äôs no z-index for **layering BrowserViews**. The only way to control stacking is by using `mainWindow.setTopBrowserView(view)`, which gets a bit tricky when managing multiple layers.  In the end, we added a `z-index` to the BrowserView in our forked version of ElectronJS.



## Layout Management

// TBD